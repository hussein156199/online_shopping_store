#include"online_store.h"
#include<stdlib.h>
#include <stdbool.h>

void displaymenu()
{
 printf("\n--------Online Shopping Store--------\n");
 printf("\n1. Add product\n");
 printf("2. Delete product\n");
 printf("3. Show available products to buy with their quantity and price\n");
 printf("4. Buy a product\n");
 printf("5. Change the price of a product\n");
 printf("6. Show products in order\n");
 printf("7. Show products in most-recent order\n");
 printf("8. Show all products sorted by their quantities. (Low to High)\n");
 printf("9. Delete all products that belong to a specific category (allow the user to choose it)\n");
 printf("10. Exit\n");
 printf("\nEnter your choice: \n");

}
//-------------------------------

void createlist(List *l)
{
 l->head=NULL;
 l->tail=NULL;
 l->Size=0;
}

//--------------------------------

int  Emptylist (List *l)
{
 return l->Size==0;
}

int  Fulllist  (List *l)
{
 return 0;
}

//--------------------------------
//Add product ((--------1--------))

void  Addproduct (List *l, DataP d)
{
  Node *n=(Node*)malloc(sizeof(Node));

  n->next=NULL;
  n->prev=NULL;

  n->data=d;

 if(l->Size==0) //empty list
    {
     l->head=n;
     l->tail=n;
    }
 else   //will add this node in tail
    {
    n->prev=l->tail;
    l->tail->next=n;
    l->tail=n;
    }
l->Size++;
}

//--------------------------------
//check id in list to achieve unique id

int CheckId (List *l, int id)
{

  Node *n=l->head;
  for(int i=0 ;i<l->Size;i++)
  {
      if (id != n->data.id)
      {
        n=n->next;
      }
     else
     {
       return 1;//when be same id in list
       break;
     }
  }

  return 0;// when be not same id in list
}

//--------------------------------------------------------
//Delete product ((------2------))

int PosofID(List *l, int id)
{
    Node *n = l->head;
    int position = 0;


    while (n != NULL)
        {
        if (id == n->data.id)
         {
            return position;
         }

        n = n->next;
        position++;
    }

    return -1;
}

//-----------------

void Delete(List *l, DataP *d)
{

    if (l->head == NULL)
        {
          printf("List is empty.\n");
          return;
        }

    *d = l->head->data;


    Node *temp = l->head->next;
    free(l->head);
    l->head = temp;

    if (l->head != NULL)
    {
      l->head->prev = NULL;
    }


    l->Size--;
}


void DeleteATpos(List *l, int pos, DataP *d)
{

    if (l->head == NULL)
    {
      printf("List is empty.\n");
      return;
    }


    if (pos < 0 || pos >= l->Size)
    {
      printf("Invalid position.\n");
      return;
    }

    Node *current = l->head;


    for (int i = 0; i < pos; i++)
    {
      current = current->next;
    }


    *d = current->data;


    if (current->prev != NULL)
    {
      current->prev->next = current->next;
    }
    else
    {
      l->head = current->next;
    }

    if (current->next != NULL)
    {
      current->next->prev = current->prev;
    }

    free(current);

    l->Size--;
}

//--------------------------------------------------------
//display product  ((------3------))

void Traverse(List *l , void(*pf)(DataP d))
{
  Node *n2=l->head;
  if (!l->head)
  {
   printf("List is empty.\n");
   return;
  }
  else
  {
  Node *n=l->head;
  for(int i=0 ;i<l->Size;i++)
    {
     (*pf)(n->data);
      n=n->next;
   }
 }
}

//--------------------------------------------------------
// Buy a product  ((------4------))

void buy (List *l ,int pos , int quantity,DataP *data)
{
  Node *n=l->head;
  for(int i=0 ; i<pos;i++)
    {
      n=n->next;
    }
  n->data.quantity=(n->data.quantity)-quantity;
  *data=n->data;

}


//--------------------------------------------------------
// change price a product  ((------5------))
void ChangePrice(List *l ,int pos ,int NewPrice, DataP *data)
{
 Node *n=l->head;
 for(int i=0 ; i<pos;i++)
    {
      n=n->next;
    }
  n->data.Price=NewPrice;
  *data=n->data;

}

//--------------------------------------------------------
// change price a product  ((------6------))

//the same to traverse function in question ((3))

//--------------------------------------------------------
// change price a product  ((------7------))

void RevTraverse(List *l , void(*pf)(DataP d))
{
  Node *n=l->tail;
  for(int i=l->Size-1 ;i>= 0;i--)
    {
     (*pf)(n->data);
      n=n->prev;
    }
}

//--------------------------------------------------------
// sort by quantity  ((------8------))

void swapNodesData(Node* a, Node* b)
{
    DataP temp = a->data;
    a->data = b->data;
    b->data = temp;
}

// Function to sort products by quantity

void sortQuantity(List* l)
 {
    bool swapped;
    Node* ptr1;
    Node* lptr = NULL;


    if (l->head == NULL)
    {
        return;
    }
    do{
        swapped = false;
        ptr1 = l->head;

        while (ptr1->next != lptr)
            {
              if (ptr1->data.quantity > ptr1->next->data.quantity)
               {
                 swapNodesData(ptr1, ptr1->next);
                 swapped = true;
               }
              ptr1 = ptr1->next;
            }
        lptr = ptr1;
     } while (swapped);

}

//--------------------------------------------------------
// delete by category  ((------9------))

int Posofcategory(List *l, char *s)
{
    Node *n = l->head;
    int position = 0;

    while (n != NULL)
    {
        if (strcmp(s, n->data.Category) != 0)
        {
            n = n->next;
            position++;
        }
        else
        {
           return position;
        }
    }

    return -1;

}

//-----------------

int id_of_category(List *l, char *s)
{
    Node *n = l->head;

    while (n != NULL)
    {
        if (strcmp(s, n->data.Category) != 0)
        {
            n = n->next;
        }
        else
        {
           return n->data.id;
        }
    }

    return -1;

}


//------------------------------
//Extra function

//insert at position

void  InsertATpos(List *l, int pos ,DataP d)
{
  Node*n=(Node*)malloc(sizeof(Node));

  Node*tmp=l->head;
  n->next=NULL;
  n->prev=NULL;
  n->data=d;

 if(l->Size ==0)
 {
   l->head=n;
   l->tail=n;
 }
 else if (pos==0)
 {
   n->next=l->head;
   l->head->prev=n;
   l->head=n;
 }
 else
 {     //will add this node in tail

  for(int i=0;i<pos-1;i++)
  {
    tmp=tmp->next;
  }

 n->prev=tmp;
 n->next=tmp->next;

 if(pos != l->Size)
 {
  tmp->next->prev=n;
  tmp->next=n;
 }
 l->Size++;
}
}

//-------------------
//size of list

int sizeList (List *l)
{
  return l->Size;
}


























